// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: commdef.proto

#ifndef PROTOBUF_commdef_2eproto__INCLUDED
#define PROTOBUF_commdef_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace commdef {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_commdef_2eproto();
void protobuf_AssignDesc_commdef_2eproto();
void protobuf_ShutdownFile_commdef_2eproto();


enum SexType {
  female = 0,
  male = 1
};
bool SexType_IsValid(int value);
const SexType SexType_MIN = female;
const SexType SexType_MAX = male;
const int SexType_ARRAYSIZE = SexType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SexType_descriptor();
inline const ::std::string& SexType_Name(SexType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SexType_descriptor(), value);
}
inline bool SexType_Parse(
    const ::std::string& name, SexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SexType>(
    SexType_descriptor(), name, value);
}
enum LeaderboardType {
  none_board = 0,
  battle_power = 1,
  region_level = 2
};
bool LeaderboardType_IsValid(int value);
const LeaderboardType LeaderboardType_MIN = none_board;
const LeaderboardType LeaderboardType_MAX = region_level;
const int LeaderboardType_ARRAYSIZE = LeaderboardType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LeaderboardType_descriptor();
inline const ::std::string& LeaderboardType_Name(LeaderboardType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LeaderboardType_descriptor(), value);
}
inline bool LeaderboardType_Parse(
    const ::std::string& name, LeaderboardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LeaderboardType>(
    LeaderboardType_descriptor(), name, value);
}
enum SkillTrigType {
  buff = 0,
  debuff = 1
};
bool SkillTrigType_IsValid(int value);
const SkillTrigType SkillTrigType_MIN = buff;
const SkillTrigType SkillTrigType_MAX = debuff;
const int SkillTrigType_ARRAYSIZE = SkillTrigType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillTrigType_descriptor();
inline const ::std::string& SkillTrigType_Name(SkillTrigType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillTrigType_descriptor(), value);
}
inline bool SkillTrigType_Parse(
    const ::std::string& name, SkillTrigType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillTrigType>(
    SkillTrigType_descriptor(), name, value);
}
enum SkillType {
  none = 0,
  sword = 1,
  fist = 2,
  knife = 3,
  talent = 10,
  pet = 11,
  QTE = 12,
  zhengwu = 13,
  moster = 14
};
bool SkillType_IsValid(int value);
const SkillType SkillType_MIN = none;
const SkillType SkillType_MAX = moster;
const int SkillType_ARRAYSIZE = SkillType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillType_descriptor();
inline const ::std::string& SkillType_Name(SkillType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillType_descriptor(), value);
}
inline bool SkillType_Parse(
    const ::std::string& name, SkillType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillType>(
    SkillType_descriptor(), name, value);
}
enum SkillTargetType {
  enemy = 0,
  self = 1,
  selfAndTeammate = 2
};
bool SkillTargetType_IsValid(int value);
const SkillTargetType SkillTargetType_MIN = enemy;
const SkillTargetType SkillTargetType_MAX = selfAndTeammate;
const int SkillTargetType_ARRAYSIZE = SkillTargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillTargetType_descriptor();
inline const ::std::string& SkillTargetType_Name(SkillTargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillTargetType_descriptor(), value);
}
inline bool SkillTargetType_Parse(
    const ::std::string& name, SkillTargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillTargetType>(
    SkillTargetType_descriptor(), name, value);
}
enum SkillSlot {
  noramlAtk = 0,
  skill1 = 1,
  skill2 = 2,
  skill3 = 3,
  weapon = 4,
  zhengwuslot = 5
};
bool SkillSlot_IsValid(int value);
const SkillSlot SkillSlot_MIN = noramlAtk;
const SkillSlot SkillSlot_MAX = zhengwuslot;
const int SkillSlot_ARRAYSIZE = SkillSlot_MAX + 1;

const ::google::protobuf::EnumDescriptor* SkillSlot_descriptor();
inline const ::std::string& SkillSlot_Name(SkillSlot value) {
  return ::google::protobuf::internal::NameOfEnum(
    SkillSlot_descriptor(), value);
}
inline bool SkillSlot_Parse(
    const ::std::string& name, SkillSlot* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillSlot>(
    SkillSlot_descriptor(), name, value);
}
enum Rules {
  Limitation_PlayerLevel = 0,
  Limitation_ColdDown = 1
};
bool Rules_IsValid(int value);
const Rules Rules_MIN = Limitation_PlayerLevel;
const Rules Rules_MAX = Limitation_ColdDown;
const int Rules_ARRAYSIZE = Rules_MAX + 1;

const ::google::protobuf::EnumDescriptor* Rules_descriptor();
inline const ::std::string& Rules_Name(Rules value) {
  return ::google::protobuf::internal::NameOfEnum(
    Rules_descriptor(), value);
}
inline bool Rules_Parse(
    const ::std::string& name, Rules* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Rules>(
    Rules_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================


// @@protoc_insertion_point(namespace_scope)

}  // namespace commdef

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commdef::SexType>() {
  return ::commdef::SexType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commdef::LeaderboardType>() {
  return ::commdef::LeaderboardType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commdef::SkillTrigType>() {
  return ::commdef::SkillTrigType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commdef::SkillType>() {
  return ::commdef::SkillType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commdef::SkillTargetType>() {
  return ::commdef::SkillTargetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commdef::SkillSlot>() {
  return ::commdef::SkillSlot_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commdef::Rules>() {
  return ::commdef::Rules_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_commdef_2eproto__INCLUDED

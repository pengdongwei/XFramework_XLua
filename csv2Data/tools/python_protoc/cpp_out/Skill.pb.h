// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Skill.proto

#ifndef PROTOBUF_Skill_2eproto__INCLUDED
#define PROTOBUF_Skill_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace dbc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Skill_2eproto();
void protobuf_AssignDesc_Skill_2eproto();
void protobuf_ShutdownFile_Skill_2eproto();

class SkillTable;
class Skill;

// ===================================================================

class SkillTable : public ::google::protobuf::Message {
 public:
  SkillTable();
  virtual ~SkillTable();

  SkillTable(const SkillTable& from);

  inline SkillTable& operator=(const SkillTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillTable& default_instance();

  void Swap(SkillTable* other);

  // implements Message ----------------------------------------------

  SkillTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillTable& from);
  void MergeFrom(const SkillTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tname = 1;
  inline bool has_tname() const;
  inline void clear_tname();
  static const int kTnameFieldNumber = 1;
  inline const ::std::string& tname() const;
  inline void set_tname(const ::std::string& value);
  inline void set_tname(const char* value);
  inline void set_tname(const char* value, size_t size);
  inline ::std::string* mutable_tname();
  inline ::std::string* release_tname();
  inline void set_allocated_tname(::std::string* tname);

  // repeated .dbc.Skill tlist = 2;
  inline int tlist_size() const;
  inline void clear_tlist();
  static const int kTlistFieldNumber = 2;
  inline const ::dbc::Skill& tlist(int index) const;
  inline ::dbc::Skill* mutable_tlist(int index);
  inline ::dbc::Skill* add_tlist();
  inline const ::google::protobuf::RepeatedPtrField< ::dbc::Skill >&
      tlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::dbc::Skill >*
      mutable_tlist();

  // @@protoc_insertion_point(class_scope:dbc.SkillTable)
 private:
  inline void set_has_tname();
  inline void clear_has_tname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tname_;
  ::google::protobuf::RepeatedPtrField< ::dbc::Skill > tlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Skill_2eproto();
  friend void protobuf_AssignDesc_Skill_2eproto();
  friend void protobuf_ShutdownFile_Skill_2eproto();

  void InitAsDefaultInstance();
  static SkillTable* default_instance_;
};
// -------------------------------------------------------------------

class Skill : public ::google::protobuf::Message {
 public:
  Skill();
  virtual ~Skill();

  Skill(const Skill& from);

  inline Skill& operator=(const Skill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Skill& default_instance();

  void Swap(Skill* other);

  // implements Message ----------------------------------------------

  Skill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Skill& from);
  void MergeFrom(const Skill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional int32 SkillValueID = 4;
  inline bool has_skillvalueid() const;
  inline void clear_skillvalueid();
  static const int kSkillValueIDFieldNumber = 4;
  inline ::google::protobuf::int32 skillvalueid() const;
  inline void set_skillvalueid(::google::protobuf::int32 value);

  // optional string ActFile = 5;
  inline bool has_actfile() const;
  inline void clear_actfile();
  static const int kActFileFieldNumber = 5;
  inline const ::std::string& actfile() const;
  inline void set_actfile(const ::std::string& value);
  inline void set_actfile(const char* value);
  inline void set_actfile(const char* value, size_t size);
  inline ::std::string* mutable_actfile();
  inline ::std::string* release_actfile();
  inline void set_allocated_actfile(::std::string* actfile);

  // optional string SoundPoint = 6;
  inline bool has_soundpoint() const;
  inline void clear_soundpoint();
  static const int kSoundPointFieldNumber = 6;
  inline const ::std::string& soundpoint() const;
  inline void set_soundpoint(const ::std::string& value);
  inline void set_soundpoint(const char* value);
  inline void set_soundpoint(const char* value, size_t size);
  inline ::std::string* mutable_soundpoint();
  inline ::std::string* release_soundpoint();
  inline void set_allocated_soundpoint(::std::string* soundpoint);

  // optional string DamagePoint = 7;
  inline bool has_damagepoint() const;
  inline void clear_damagepoint();
  static const int kDamagePointFieldNumber = 7;
  inline const ::std::string& damagepoint() const;
  inline void set_damagepoint(const ::std::string& value);
  inline void set_damagepoint(const char* value);
  inline void set_damagepoint(const char* value, size_t size);
  inline ::std::string* mutable_damagepoint();
  inline ::std::string* release_damagepoint();
  inline void set_allocated_damagepoint(::std::string* damagepoint);

  // optional string JointPoint = 8;
  inline bool has_jointpoint() const;
  inline void clear_jointpoint();
  static const int kJointPointFieldNumber = 8;
  inline const ::std::string& jointpoint() const;
  inline void set_jointpoint(const ::std::string& value);
  inline void set_jointpoint(const char* value);
  inline void set_jointpoint(const char* value, size_t size);
  inline ::std::string* mutable_jointpoint();
  inline ::std::string* release_jointpoint();
  inline void set_allocated_jointpoint(::std::string* jointpoint);

  // optional string BeatPoint = 9;
  inline bool has_beatpoint() const;
  inline void clear_beatpoint();
  static const int kBeatPointFieldNumber = 9;
  inline const ::std::string& beatpoint() const;
  inline void set_beatpoint(const ::std::string& value);
  inline void set_beatpoint(const char* value);
  inline void set_beatpoint(const char* value, size_t size);
  inline ::std::string* mutable_beatpoint();
  inline ::std::string* release_beatpoint();
  inline void set_allocated_beatpoint(::std::string* beatpoint);

  // optional string CameraPoint = 10;
  inline bool has_camerapoint() const;
  inline void clear_camerapoint();
  static const int kCameraPointFieldNumber = 10;
  inline const ::std::string& camerapoint() const;
  inline void set_camerapoint(const ::std::string& value);
  inline void set_camerapoint(const char* value);
  inline void set_camerapoint(const char* value, size_t size);
  inline ::std::string* mutable_camerapoint();
  inline ::std::string* release_camerapoint();
  inline void set_allocated_camerapoint(::std::string* camerapoint);

  // optional string EffFile1 = 11;
  inline bool has_efffile1() const;
  inline void clear_efffile1();
  static const int kEffFile1FieldNumber = 11;
  inline const ::std::string& efffile1() const;
  inline void set_efffile1(const ::std::string& value);
  inline void set_efffile1(const char* value);
  inline void set_efffile1(const char* value, size_t size);
  inline ::std::string* mutable_efffile1();
  inline ::std::string* release_efffile1();
  inline void set_allocated_efffile1(::std::string* efffile1);

  // optional string EffPoint1 = 12;
  inline bool has_effpoint1() const;
  inline void clear_effpoint1();
  static const int kEffPoint1FieldNumber = 12;
  inline const ::std::string& effpoint1() const;
  inline void set_effpoint1(const ::std::string& value);
  inline void set_effpoint1(const char* value);
  inline void set_effpoint1(const char* value, size_t size);
  inline ::std::string* mutable_effpoint1();
  inline ::std::string* release_effpoint1();
  inline void set_allocated_effpoint1(::std::string* effpoint1);

  // optional string EffFile2 = 13;
  inline bool has_efffile2() const;
  inline void clear_efffile2();
  static const int kEffFile2FieldNumber = 13;
  inline const ::std::string& efffile2() const;
  inline void set_efffile2(const ::std::string& value);
  inline void set_efffile2(const char* value);
  inline void set_efffile2(const char* value, size_t size);
  inline ::std::string* mutable_efffile2();
  inline ::std::string* release_efffile2();
  inline void set_allocated_efffile2(::std::string* efffile2);

  // optional string EffPoint2 = 14;
  inline bool has_effpoint2() const;
  inline void clear_effpoint2();
  static const int kEffPoint2FieldNumber = 14;
  inline const ::std::string& effpoint2() const;
  inline void set_effpoint2(const ::std::string& value);
  inline void set_effpoint2(const char* value);
  inline void set_effpoint2(const char* value, size_t size);
  inline ::std::string* mutable_effpoint2();
  inline ::std::string* release_effpoint2();
  inline void set_allocated_effpoint2(::std::string* effpoint2);

  // optional string EffFile3 = 15;
  inline bool has_efffile3() const;
  inline void clear_efffile3();
  static const int kEffFile3FieldNumber = 15;
  inline const ::std::string& efffile3() const;
  inline void set_efffile3(const ::std::string& value);
  inline void set_efffile3(const char* value);
  inline void set_efffile3(const char* value, size_t size);
  inline ::std::string* mutable_efffile3();
  inline ::std::string* release_efffile3();
  inline void set_allocated_efffile3(::std::string* efffile3);

  // optional string EffPoint3 = 16;
  inline bool has_effpoint3() const;
  inline void clear_effpoint3();
  static const int kEffPoint3FieldNumber = 16;
  inline const ::std::string& effpoint3() const;
  inline void set_effpoint3(const ::std::string& value);
  inline void set_effpoint3(const char* value);
  inline void set_effpoint3(const char* value, size_t size);
  inline ::std::string* mutable_effpoint3();
  inline ::std::string* release_effpoint3();
  inline void set_allocated_effpoint3(::std::string* effpoint3);

  // @@protoc_insertion_point(class_scope:dbc.Skill)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_skillvalueid();
  inline void clear_has_skillvalueid();
  inline void set_has_actfile();
  inline void clear_has_actfile();
  inline void set_has_soundpoint();
  inline void clear_has_soundpoint();
  inline void set_has_damagepoint();
  inline void clear_has_damagepoint();
  inline void set_has_jointpoint();
  inline void clear_has_jointpoint();
  inline void set_has_beatpoint();
  inline void clear_has_beatpoint();
  inline void set_has_camerapoint();
  inline void clear_has_camerapoint();
  inline void set_has_efffile1();
  inline void clear_has_efffile1();
  inline void set_has_effpoint1();
  inline void clear_has_effpoint1();
  inline void set_has_efffile2();
  inline void clear_has_efffile2();
  inline void set_has_effpoint2();
  inline void clear_has_effpoint2();
  inline void set_has_efffile3();
  inline void clear_has_efffile3();
  inline void set_has_effpoint3();
  inline void clear_has_effpoint3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 skillvalueid_;
  ::std::string* desc_;
  ::std::string* actfile_;
  ::std::string* soundpoint_;
  ::std::string* damagepoint_;
  ::std::string* jointpoint_;
  ::std::string* beatpoint_;
  ::std::string* camerapoint_;
  ::std::string* efffile1_;
  ::std::string* effpoint1_;
  ::std::string* efffile2_;
  ::std::string* effpoint2_;
  ::std::string* efffile3_;
  ::std::string* effpoint3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_Skill_2eproto();
  friend void protobuf_AssignDesc_Skill_2eproto();
  friend void protobuf_ShutdownFile_Skill_2eproto();

  void InitAsDefaultInstance();
  static Skill* default_instance_;
};
// ===================================================================


// ===================================================================

// SkillTable

// optional string tname = 1;
inline bool SkillTable::has_tname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillTable::set_has_tname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillTable::clear_has_tname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillTable::clear_tname() {
  if (tname_ != &::google::protobuf::internal::kEmptyString) {
    tname_->clear();
  }
  clear_has_tname();
}
inline const ::std::string& SkillTable::tname() const {
  return *tname_;
}
inline void SkillTable::set_tname(const ::std::string& value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
}
inline void SkillTable::set_tname(const char* value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
}
inline void SkillTable::set_tname(const char* value, size_t size) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  tname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillTable::mutable_tname() {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  return tname_;
}
inline ::std::string* SkillTable::release_tname() {
  clear_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tname_;
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillTable::set_allocated_tname(::std::string* tname) {
  if (tname_ != &::google::protobuf::internal::kEmptyString) {
    delete tname_;
  }
  if (tname) {
    set_has_tname();
    tname_ = tname;
  } else {
    clear_has_tname();
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dbc.Skill tlist = 2;
inline int SkillTable::tlist_size() const {
  return tlist_.size();
}
inline void SkillTable::clear_tlist() {
  tlist_.Clear();
}
inline const ::dbc::Skill& SkillTable::tlist(int index) const {
  return tlist_.Get(index);
}
inline ::dbc::Skill* SkillTable::mutable_tlist(int index) {
  return tlist_.Mutable(index);
}
inline ::dbc::Skill* SkillTable::add_tlist() {
  return tlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dbc::Skill >&
SkillTable::tlist() const {
  return tlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::dbc::Skill >*
SkillTable::mutable_tlist() {
  return &tlist_;
}

// -------------------------------------------------------------------

// Skill

// optional int32 ID = 1;
inline bool Skill::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Skill::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Skill::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Skill::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Skill::id() const {
  return id_;
}
inline void Skill::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string Name = 2;
inline bool Skill::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Skill::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Skill::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Skill::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Skill::name() const {
  return *name_;
}
inline void Skill::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Skill::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Skill::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Skill::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Desc = 3;
inline bool Skill::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Skill::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Skill::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Skill::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Skill::desc() const {
  return *desc_;
}
inline void Skill::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Skill::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Skill::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* Skill::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 SkillValueID = 4;
inline bool Skill::has_skillvalueid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Skill::set_has_skillvalueid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Skill::clear_has_skillvalueid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Skill::clear_skillvalueid() {
  skillvalueid_ = 0;
  clear_has_skillvalueid();
}
inline ::google::protobuf::int32 Skill::skillvalueid() const {
  return skillvalueid_;
}
inline void Skill::set_skillvalueid(::google::protobuf::int32 value) {
  set_has_skillvalueid();
  skillvalueid_ = value;
}

// optional string ActFile = 5;
inline bool Skill::has_actfile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Skill::set_has_actfile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Skill::clear_has_actfile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Skill::clear_actfile() {
  if (actfile_ != &::google::protobuf::internal::kEmptyString) {
    actfile_->clear();
  }
  clear_has_actfile();
}
inline const ::std::string& Skill::actfile() const {
  return *actfile_;
}
inline void Skill::set_actfile(const ::std::string& value) {
  set_has_actfile();
  if (actfile_ == &::google::protobuf::internal::kEmptyString) {
    actfile_ = new ::std::string;
  }
  actfile_->assign(value);
}
inline void Skill::set_actfile(const char* value) {
  set_has_actfile();
  if (actfile_ == &::google::protobuf::internal::kEmptyString) {
    actfile_ = new ::std::string;
  }
  actfile_->assign(value);
}
inline void Skill::set_actfile(const char* value, size_t size) {
  set_has_actfile();
  if (actfile_ == &::google::protobuf::internal::kEmptyString) {
    actfile_ = new ::std::string;
  }
  actfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_actfile() {
  set_has_actfile();
  if (actfile_ == &::google::protobuf::internal::kEmptyString) {
    actfile_ = new ::std::string;
  }
  return actfile_;
}
inline ::std::string* Skill::release_actfile() {
  clear_has_actfile();
  if (actfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actfile_;
    actfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_actfile(::std::string* actfile) {
  if (actfile_ != &::google::protobuf::internal::kEmptyString) {
    delete actfile_;
  }
  if (actfile) {
    set_has_actfile();
    actfile_ = actfile;
  } else {
    clear_has_actfile();
    actfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SoundPoint = 6;
inline bool Skill::has_soundpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Skill::set_has_soundpoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Skill::clear_has_soundpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Skill::clear_soundpoint() {
  if (soundpoint_ != &::google::protobuf::internal::kEmptyString) {
    soundpoint_->clear();
  }
  clear_has_soundpoint();
}
inline const ::std::string& Skill::soundpoint() const {
  return *soundpoint_;
}
inline void Skill::set_soundpoint(const ::std::string& value) {
  set_has_soundpoint();
  if (soundpoint_ == &::google::protobuf::internal::kEmptyString) {
    soundpoint_ = new ::std::string;
  }
  soundpoint_->assign(value);
}
inline void Skill::set_soundpoint(const char* value) {
  set_has_soundpoint();
  if (soundpoint_ == &::google::protobuf::internal::kEmptyString) {
    soundpoint_ = new ::std::string;
  }
  soundpoint_->assign(value);
}
inline void Skill::set_soundpoint(const char* value, size_t size) {
  set_has_soundpoint();
  if (soundpoint_ == &::google::protobuf::internal::kEmptyString) {
    soundpoint_ = new ::std::string;
  }
  soundpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_soundpoint() {
  set_has_soundpoint();
  if (soundpoint_ == &::google::protobuf::internal::kEmptyString) {
    soundpoint_ = new ::std::string;
  }
  return soundpoint_;
}
inline ::std::string* Skill::release_soundpoint() {
  clear_has_soundpoint();
  if (soundpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soundpoint_;
    soundpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_soundpoint(::std::string* soundpoint) {
  if (soundpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete soundpoint_;
  }
  if (soundpoint) {
    set_has_soundpoint();
    soundpoint_ = soundpoint;
  } else {
    clear_has_soundpoint();
    soundpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DamagePoint = 7;
inline bool Skill::has_damagepoint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Skill::set_has_damagepoint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Skill::clear_has_damagepoint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Skill::clear_damagepoint() {
  if (damagepoint_ != &::google::protobuf::internal::kEmptyString) {
    damagepoint_->clear();
  }
  clear_has_damagepoint();
}
inline const ::std::string& Skill::damagepoint() const {
  return *damagepoint_;
}
inline void Skill::set_damagepoint(const ::std::string& value) {
  set_has_damagepoint();
  if (damagepoint_ == &::google::protobuf::internal::kEmptyString) {
    damagepoint_ = new ::std::string;
  }
  damagepoint_->assign(value);
}
inline void Skill::set_damagepoint(const char* value) {
  set_has_damagepoint();
  if (damagepoint_ == &::google::protobuf::internal::kEmptyString) {
    damagepoint_ = new ::std::string;
  }
  damagepoint_->assign(value);
}
inline void Skill::set_damagepoint(const char* value, size_t size) {
  set_has_damagepoint();
  if (damagepoint_ == &::google::protobuf::internal::kEmptyString) {
    damagepoint_ = new ::std::string;
  }
  damagepoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_damagepoint() {
  set_has_damagepoint();
  if (damagepoint_ == &::google::protobuf::internal::kEmptyString) {
    damagepoint_ = new ::std::string;
  }
  return damagepoint_;
}
inline ::std::string* Skill::release_damagepoint() {
  clear_has_damagepoint();
  if (damagepoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = damagepoint_;
    damagepoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_damagepoint(::std::string* damagepoint) {
  if (damagepoint_ != &::google::protobuf::internal::kEmptyString) {
    delete damagepoint_;
  }
  if (damagepoint) {
    set_has_damagepoint();
    damagepoint_ = damagepoint;
  } else {
    clear_has_damagepoint();
    damagepoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string JointPoint = 8;
inline bool Skill::has_jointpoint() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Skill::set_has_jointpoint() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Skill::clear_has_jointpoint() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Skill::clear_jointpoint() {
  if (jointpoint_ != &::google::protobuf::internal::kEmptyString) {
    jointpoint_->clear();
  }
  clear_has_jointpoint();
}
inline const ::std::string& Skill::jointpoint() const {
  return *jointpoint_;
}
inline void Skill::set_jointpoint(const ::std::string& value) {
  set_has_jointpoint();
  if (jointpoint_ == &::google::protobuf::internal::kEmptyString) {
    jointpoint_ = new ::std::string;
  }
  jointpoint_->assign(value);
}
inline void Skill::set_jointpoint(const char* value) {
  set_has_jointpoint();
  if (jointpoint_ == &::google::protobuf::internal::kEmptyString) {
    jointpoint_ = new ::std::string;
  }
  jointpoint_->assign(value);
}
inline void Skill::set_jointpoint(const char* value, size_t size) {
  set_has_jointpoint();
  if (jointpoint_ == &::google::protobuf::internal::kEmptyString) {
    jointpoint_ = new ::std::string;
  }
  jointpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_jointpoint() {
  set_has_jointpoint();
  if (jointpoint_ == &::google::protobuf::internal::kEmptyString) {
    jointpoint_ = new ::std::string;
  }
  return jointpoint_;
}
inline ::std::string* Skill::release_jointpoint() {
  clear_has_jointpoint();
  if (jointpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jointpoint_;
    jointpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_jointpoint(::std::string* jointpoint) {
  if (jointpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete jointpoint_;
  }
  if (jointpoint) {
    set_has_jointpoint();
    jointpoint_ = jointpoint;
  } else {
    clear_has_jointpoint();
    jointpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string BeatPoint = 9;
inline bool Skill::has_beatpoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Skill::set_has_beatpoint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Skill::clear_has_beatpoint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Skill::clear_beatpoint() {
  if (beatpoint_ != &::google::protobuf::internal::kEmptyString) {
    beatpoint_->clear();
  }
  clear_has_beatpoint();
}
inline const ::std::string& Skill::beatpoint() const {
  return *beatpoint_;
}
inline void Skill::set_beatpoint(const ::std::string& value) {
  set_has_beatpoint();
  if (beatpoint_ == &::google::protobuf::internal::kEmptyString) {
    beatpoint_ = new ::std::string;
  }
  beatpoint_->assign(value);
}
inline void Skill::set_beatpoint(const char* value) {
  set_has_beatpoint();
  if (beatpoint_ == &::google::protobuf::internal::kEmptyString) {
    beatpoint_ = new ::std::string;
  }
  beatpoint_->assign(value);
}
inline void Skill::set_beatpoint(const char* value, size_t size) {
  set_has_beatpoint();
  if (beatpoint_ == &::google::protobuf::internal::kEmptyString) {
    beatpoint_ = new ::std::string;
  }
  beatpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_beatpoint() {
  set_has_beatpoint();
  if (beatpoint_ == &::google::protobuf::internal::kEmptyString) {
    beatpoint_ = new ::std::string;
  }
  return beatpoint_;
}
inline ::std::string* Skill::release_beatpoint() {
  clear_has_beatpoint();
  if (beatpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beatpoint_;
    beatpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_beatpoint(::std::string* beatpoint) {
  if (beatpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete beatpoint_;
  }
  if (beatpoint) {
    set_has_beatpoint();
    beatpoint_ = beatpoint;
  } else {
    clear_has_beatpoint();
    beatpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CameraPoint = 10;
inline bool Skill::has_camerapoint() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Skill::set_has_camerapoint() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Skill::clear_has_camerapoint() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Skill::clear_camerapoint() {
  if (camerapoint_ != &::google::protobuf::internal::kEmptyString) {
    camerapoint_->clear();
  }
  clear_has_camerapoint();
}
inline const ::std::string& Skill::camerapoint() const {
  return *camerapoint_;
}
inline void Skill::set_camerapoint(const ::std::string& value) {
  set_has_camerapoint();
  if (camerapoint_ == &::google::protobuf::internal::kEmptyString) {
    camerapoint_ = new ::std::string;
  }
  camerapoint_->assign(value);
}
inline void Skill::set_camerapoint(const char* value) {
  set_has_camerapoint();
  if (camerapoint_ == &::google::protobuf::internal::kEmptyString) {
    camerapoint_ = new ::std::string;
  }
  camerapoint_->assign(value);
}
inline void Skill::set_camerapoint(const char* value, size_t size) {
  set_has_camerapoint();
  if (camerapoint_ == &::google::protobuf::internal::kEmptyString) {
    camerapoint_ = new ::std::string;
  }
  camerapoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_camerapoint() {
  set_has_camerapoint();
  if (camerapoint_ == &::google::protobuf::internal::kEmptyString) {
    camerapoint_ = new ::std::string;
  }
  return camerapoint_;
}
inline ::std::string* Skill::release_camerapoint() {
  clear_has_camerapoint();
  if (camerapoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = camerapoint_;
    camerapoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_camerapoint(::std::string* camerapoint) {
  if (camerapoint_ != &::google::protobuf::internal::kEmptyString) {
    delete camerapoint_;
  }
  if (camerapoint) {
    set_has_camerapoint();
    camerapoint_ = camerapoint;
  } else {
    clear_has_camerapoint();
    camerapoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string EffFile1 = 11;
inline bool Skill::has_efffile1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Skill::set_has_efffile1() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Skill::clear_has_efffile1() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Skill::clear_efffile1() {
  if (efffile1_ != &::google::protobuf::internal::kEmptyString) {
    efffile1_->clear();
  }
  clear_has_efffile1();
}
inline const ::std::string& Skill::efffile1() const {
  return *efffile1_;
}
inline void Skill::set_efffile1(const ::std::string& value) {
  set_has_efffile1();
  if (efffile1_ == &::google::protobuf::internal::kEmptyString) {
    efffile1_ = new ::std::string;
  }
  efffile1_->assign(value);
}
inline void Skill::set_efffile1(const char* value) {
  set_has_efffile1();
  if (efffile1_ == &::google::protobuf::internal::kEmptyString) {
    efffile1_ = new ::std::string;
  }
  efffile1_->assign(value);
}
inline void Skill::set_efffile1(const char* value, size_t size) {
  set_has_efffile1();
  if (efffile1_ == &::google::protobuf::internal::kEmptyString) {
    efffile1_ = new ::std::string;
  }
  efffile1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_efffile1() {
  set_has_efffile1();
  if (efffile1_ == &::google::protobuf::internal::kEmptyString) {
    efffile1_ = new ::std::string;
  }
  return efffile1_;
}
inline ::std::string* Skill::release_efffile1() {
  clear_has_efffile1();
  if (efffile1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = efffile1_;
    efffile1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_efffile1(::std::string* efffile1) {
  if (efffile1_ != &::google::protobuf::internal::kEmptyString) {
    delete efffile1_;
  }
  if (efffile1) {
    set_has_efffile1();
    efffile1_ = efffile1;
  } else {
    clear_has_efffile1();
    efffile1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string EffPoint1 = 12;
inline bool Skill::has_effpoint1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Skill::set_has_effpoint1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Skill::clear_has_effpoint1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Skill::clear_effpoint1() {
  if (effpoint1_ != &::google::protobuf::internal::kEmptyString) {
    effpoint1_->clear();
  }
  clear_has_effpoint1();
}
inline const ::std::string& Skill::effpoint1() const {
  return *effpoint1_;
}
inline void Skill::set_effpoint1(const ::std::string& value) {
  set_has_effpoint1();
  if (effpoint1_ == &::google::protobuf::internal::kEmptyString) {
    effpoint1_ = new ::std::string;
  }
  effpoint1_->assign(value);
}
inline void Skill::set_effpoint1(const char* value) {
  set_has_effpoint1();
  if (effpoint1_ == &::google::protobuf::internal::kEmptyString) {
    effpoint1_ = new ::std::string;
  }
  effpoint1_->assign(value);
}
inline void Skill::set_effpoint1(const char* value, size_t size) {
  set_has_effpoint1();
  if (effpoint1_ == &::google::protobuf::internal::kEmptyString) {
    effpoint1_ = new ::std::string;
  }
  effpoint1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_effpoint1() {
  set_has_effpoint1();
  if (effpoint1_ == &::google::protobuf::internal::kEmptyString) {
    effpoint1_ = new ::std::string;
  }
  return effpoint1_;
}
inline ::std::string* Skill::release_effpoint1() {
  clear_has_effpoint1();
  if (effpoint1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effpoint1_;
    effpoint1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_effpoint1(::std::string* effpoint1) {
  if (effpoint1_ != &::google::protobuf::internal::kEmptyString) {
    delete effpoint1_;
  }
  if (effpoint1) {
    set_has_effpoint1();
    effpoint1_ = effpoint1;
  } else {
    clear_has_effpoint1();
    effpoint1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string EffFile2 = 13;
inline bool Skill::has_efffile2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Skill::set_has_efffile2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Skill::clear_has_efffile2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Skill::clear_efffile2() {
  if (efffile2_ != &::google::protobuf::internal::kEmptyString) {
    efffile2_->clear();
  }
  clear_has_efffile2();
}
inline const ::std::string& Skill::efffile2() const {
  return *efffile2_;
}
inline void Skill::set_efffile2(const ::std::string& value) {
  set_has_efffile2();
  if (efffile2_ == &::google::protobuf::internal::kEmptyString) {
    efffile2_ = new ::std::string;
  }
  efffile2_->assign(value);
}
inline void Skill::set_efffile2(const char* value) {
  set_has_efffile2();
  if (efffile2_ == &::google::protobuf::internal::kEmptyString) {
    efffile2_ = new ::std::string;
  }
  efffile2_->assign(value);
}
inline void Skill::set_efffile2(const char* value, size_t size) {
  set_has_efffile2();
  if (efffile2_ == &::google::protobuf::internal::kEmptyString) {
    efffile2_ = new ::std::string;
  }
  efffile2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_efffile2() {
  set_has_efffile2();
  if (efffile2_ == &::google::protobuf::internal::kEmptyString) {
    efffile2_ = new ::std::string;
  }
  return efffile2_;
}
inline ::std::string* Skill::release_efffile2() {
  clear_has_efffile2();
  if (efffile2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = efffile2_;
    efffile2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_efffile2(::std::string* efffile2) {
  if (efffile2_ != &::google::protobuf::internal::kEmptyString) {
    delete efffile2_;
  }
  if (efffile2) {
    set_has_efffile2();
    efffile2_ = efffile2;
  } else {
    clear_has_efffile2();
    efffile2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string EffPoint2 = 14;
inline bool Skill::has_effpoint2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Skill::set_has_effpoint2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Skill::clear_has_effpoint2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Skill::clear_effpoint2() {
  if (effpoint2_ != &::google::protobuf::internal::kEmptyString) {
    effpoint2_->clear();
  }
  clear_has_effpoint2();
}
inline const ::std::string& Skill::effpoint2() const {
  return *effpoint2_;
}
inline void Skill::set_effpoint2(const ::std::string& value) {
  set_has_effpoint2();
  if (effpoint2_ == &::google::protobuf::internal::kEmptyString) {
    effpoint2_ = new ::std::string;
  }
  effpoint2_->assign(value);
}
inline void Skill::set_effpoint2(const char* value) {
  set_has_effpoint2();
  if (effpoint2_ == &::google::protobuf::internal::kEmptyString) {
    effpoint2_ = new ::std::string;
  }
  effpoint2_->assign(value);
}
inline void Skill::set_effpoint2(const char* value, size_t size) {
  set_has_effpoint2();
  if (effpoint2_ == &::google::protobuf::internal::kEmptyString) {
    effpoint2_ = new ::std::string;
  }
  effpoint2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_effpoint2() {
  set_has_effpoint2();
  if (effpoint2_ == &::google::protobuf::internal::kEmptyString) {
    effpoint2_ = new ::std::string;
  }
  return effpoint2_;
}
inline ::std::string* Skill::release_effpoint2() {
  clear_has_effpoint2();
  if (effpoint2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effpoint2_;
    effpoint2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_effpoint2(::std::string* effpoint2) {
  if (effpoint2_ != &::google::protobuf::internal::kEmptyString) {
    delete effpoint2_;
  }
  if (effpoint2) {
    set_has_effpoint2();
    effpoint2_ = effpoint2;
  } else {
    clear_has_effpoint2();
    effpoint2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string EffFile3 = 15;
inline bool Skill::has_efffile3() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Skill::set_has_efffile3() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Skill::clear_has_efffile3() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Skill::clear_efffile3() {
  if (efffile3_ != &::google::protobuf::internal::kEmptyString) {
    efffile3_->clear();
  }
  clear_has_efffile3();
}
inline const ::std::string& Skill::efffile3() const {
  return *efffile3_;
}
inline void Skill::set_efffile3(const ::std::string& value) {
  set_has_efffile3();
  if (efffile3_ == &::google::protobuf::internal::kEmptyString) {
    efffile3_ = new ::std::string;
  }
  efffile3_->assign(value);
}
inline void Skill::set_efffile3(const char* value) {
  set_has_efffile3();
  if (efffile3_ == &::google::protobuf::internal::kEmptyString) {
    efffile3_ = new ::std::string;
  }
  efffile3_->assign(value);
}
inline void Skill::set_efffile3(const char* value, size_t size) {
  set_has_efffile3();
  if (efffile3_ == &::google::protobuf::internal::kEmptyString) {
    efffile3_ = new ::std::string;
  }
  efffile3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_efffile3() {
  set_has_efffile3();
  if (efffile3_ == &::google::protobuf::internal::kEmptyString) {
    efffile3_ = new ::std::string;
  }
  return efffile3_;
}
inline ::std::string* Skill::release_efffile3() {
  clear_has_efffile3();
  if (efffile3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = efffile3_;
    efffile3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_efffile3(::std::string* efffile3) {
  if (efffile3_ != &::google::protobuf::internal::kEmptyString) {
    delete efffile3_;
  }
  if (efffile3) {
    set_has_efffile3();
    efffile3_ = efffile3;
  } else {
    clear_has_efffile3();
    efffile3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string EffPoint3 = 16;
inline bool Skill::has_effpoint3() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Skill::set_has_effpoint3() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Skill::clear_has_effpoint3() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Skill::clear_effpoint3() {
  if (effpoint3_ != &::google::protobuf::internal::kEmptyString) {
    effpoint3_->clear();
  }
  clear_has_effpoint3();
}
inline const ::std::string& Skill::effpoint3() const {
  return *effpoint3_;
}
inline void Skill::set_effpoint3(const ::std::string& value) {
  set_has_effpoint3();
  if (effpoint3_ == &::google::protobuf::internal::kEmptyString) {
    effpoint3_ = new ::std::string;
  }
  effpoint3_->assign(value);
}
inline void Skill::set_effpoint3(const char* value) {
  set_has_effpoint3();
  if (effpoint3_ == &::google::protobuf::internal::kEmptyString) {
    effpoint3_ = new ::std::string;
  }
  effpoint3_->assign(value);
}
inline void Skill::set_effpoint3(const char* value, size_t size) {
  set_has_effpoint3();
  if (effpoint3_ == &::google::protobuf::internal::kEmptyString) {
    effpoint3_ = new ::std::string;
  }
  effpoint3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_effpoint3() {
  set_has_effpoint3();
  if (effpoint3_ == &::google::protobuf::internal::kEmptyString) {
    effpoint3_ = new ::std::string;
  }
  return effpoint3_;
}
inline ::std::string* Skill::release_effpoint3() {
  clear_has_effpoint3();
  if (effpoint3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effpoint3_;
    effpoint3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_effpoint3(::std::string* effpoint3) {
  if (effpoint3_ != &::google::protobuf::internal::kEmptyString) {
    delete effpoint3_;
  }
  if (effpoint3) {
    set_has_effpoint3();
    effpoint3_ = effpoint3;
  } else {
    clear_has_effpoint3();
    effpoint3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dbc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Skill_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SkillValue.proto

#ifndef PROTOBUF_SkillValue_2eproto__INCLUDED
#define PROTOBUF_SkillValue_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace dbc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SkillValue_2eproto();
void protobuf_AssignDesc_SkillValue_2eproto();
void protobuf_ShutdownFile_SkillValue_2eproto();

class SkillValueTable;
class SkillValue;

// ===================================================================

class SkillValueTable : public ::google::protobuf::Message {
 public:
  SkillValueTable();
  virtual ~SkillValueTable();

  SkillValueTable(const SkillValueTable& from);

  inline SkillValueTable& operator=(const SkillValueTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillValueTable& default_instance();

  void Swap(SkillValueTable* other);

  // implements Message ----------------------------------------------

  SkillValueTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillValueTable& from);
  void MergeFrom(const SkillValueTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tname = 1;
  inline bool has_tname() const;
  inline void clear_tname();
  static const int kTnameFieldNumber = 1;
  inline const ::std::string& tname() const;
  inline void set_tname(const ::std::string& value);
  inline void set_tname(const char* value);
  inline void set_tname(const char* value, size_t size);
  inline ::std::string* mutable_tname();
  inline ::std::string* release_tname();
  inline void set_allocated_tname(::std::string* tname);

  // repeated .dbc.SkillValue tlist = 2;
  inline int tlist_size() const;
  inline void clear_tlist();
  static const int kTlistFieldNumber = 2;
  inline const ::dbc::SkillValue& tlist(int index) const;
  inline ::dbc::SkillValue* mutable_tlist(int index);
  inline ::dbc::SkillValue* add_tlist();
  inline const ::google::protobuf::RepeatedPtrField< ::dbc::SkillValue >&
      tlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::dbc::SkillValue >*
      mutable_tlist();

  // @@protoc_insertion_point(class_scope:dbc.SkillValueTable)
 private:
  inline void set_has_tname();
  inline void clear_has_tname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tname_;
  ::google::protobuf::RepeatedPtrField< ::dbc::SkillValue > tlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SkillValue_2eproto();
  friend void protobuf_AssignDesc_SkillValue_2eproto();
  friend void protobuf_ShutdownFile_SkillValue_2eproto();

  void InitAsDefaultInstance();
  static SkillValueTable* default_instance_;
};
// -------------------------------------------------------------------

class SkillValue : public ::google::protobuf::Message {
 public:
  SkillValue();
  virtual ~SkillValue();

  SkillValue(const SkillValue& from);

  inline SkillValue& operator=(const SkillValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillValue& default_instance();

  void Swap(SkillValue* other);

  // implements Message ----------------------------------------------

  SkillValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillValue& from);
  void MergeFrom(const SkillValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string Icon = 4;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 4;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional int32 Type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 TrigType = 6;
  inline bool has_trigtype() const;
  inline void clear_trigtype();
  static const int kTrigTypeFieldNumber = 6;
  inline ::google::protobuf::int32 trigtype() const;
  inline void set_trigtype(::google::protobuf::int32 value);

  // optional int32 Slot = 7;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 7;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // optional float CD = 8;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCDFieldNumber = 8;
  inline float cd() const;
  inline void set_cd(float value);

  // optional int32 Level = 9;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 9;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 UpgradeGold = 10;
  inline bool has_upgradegold() const;
  inline void clear_upgradegold();
  static const int kUpgradeGoldFieldNumber = 10;
  inline ::google::protobuf::int32 upgradegold() const;
  inline void set_upgradegold(::google::protobuf::int32 value);

  // optional int32 UpgradeMat = 11;
  inline bool has_upgrademat() const;
  inline void clear_upgrademat();
  static const int kUpgradeMatFieldNumber = 11;
  inline ::google::protobuf::int32 upgrademat() const;
  inline void set_upgrademat(::google::protobuf::int32 value);

  // optional int32 MatNum = 12;
  inline bool has_matnum() const;
  inline void clear_matnum();
  static const int kMatNumFieldNumber = 12;
  inline ::google::protobuf::int32 matnum() const;
  inline void set_matnum(::google::protobuf::int32 value);

  // optional int32 TargetType = 13;
  inline bool has_targettype() const;
  inline void clear_targettype();
  static const int kTargetTypeFieldNumber = 13;
  inline ::google::protobuf::int32 targettype() const;
  inline void set_targettype(::google::protobuf::int32 value);

  // optional int32 TargetCnt = 14;
  inline bool has_targetcnt() const;
  inline void clear_targetcnt();
  static const int kTargetCntFieldNumber = 14;
  inline ::google::protobuf::int32 targetcnt() const;
  inline void set_targetcnt(::google::protobuf::int32 value);

  // optional int32 HurtType = 15;
  inline bool has_hurttype() const;
  inline void clear_hurttype();
  static const int kHurtTypeFieldNumber = 15;
  inline ::google::protobuf::int32 hurttype() const;
  inline void set_hurttype(::google::protobuf::int32 value);

  // optional float DamFactor = 16;
  inline bool has_damfactor() const;
  inline void clear_damfactor();
  static const int kDamFactorFieldNumber = 16;
  inline float damfactor() const;
  inline void set_damfactor(float value);

  // optional float DamAddtion = 17;
  inline bool has_damaddtion() const;
  inline void clear_damaddtion();
  static const int kDamAddtionFieldNumber = 17;
  inline float damaddtion() const;
  inline void set_damaddtion(float value);

  // optional float BuffTrigRate = 18;
  inline bool has_bufftrigrate() const;
  inline void clear_bufftrigrate();
  static const int kBuffTrigRateFieldNumber = 18;
  inline float bufftrigrate() const;
  inline void set_bufftrigrate(float value);

  // optional int32 BuffID = 19;
  inline bool has_buffid() const;
  inline void clear_buffid();
  static const int kBuffIDFieldNumber = 19;
  inline ::google::protobuf::int32 buffid() const;
  inline void set_buffid(::google::protobuf::int32 value);

  // optional float EnmityAddtion = 20;
  inline bool has_enmityaddtion() const;
  inline void clear_enmityaddtion();
  static const int kEnmityAddtionFieldNumber = 20;
  inline float enmityaddtion() const;
  inline void set_enmityaddtion(float value);

  // optional float SoulAddtion = 21;
  inline bool has_souladdtion() const;
  inline void clear_souladdtion();
  static const int kSoulAddtionFieldNumber = 21;
  inline float souladdtion() const;
  inline void set_souladdtion(float value);

  // optional bool IsBrk = 22;
  inline bool has_isbrk() const;
  inline void clear_isbrk();
  static const int kIsBrkFieldNumber = 22;
  inline bool isbrk() const;
  inline void set_isbrk(bool value);

  // optional bool IsFireCtrl = 23;
  inline bool has_isfirectrl() const;
  inline void clear_isfirectrl();
  static const int kIsFireCtrlFieldNumber = 23;
  inline bool isfirectrl() const;
  inline void set_isfirectrl(bool value);

  // optional float FlashRange = 24;
  inline bool has_flashrange() const;
  inline void clear_flashrange();
  static const int kFlashRangeFieldNumber = 24;
  inline float flashrange() const;
  inline void set_flashrange(float value);

  // optional bool IsVerify = 25;
  inline bool has_isverify() const;
  inline void clear_isverify();
  static const int kIsVerifyFieldNumber = 25;
  inline bool isverify() const;
  inline void set_isverify(bool value);

  // optional int32 AddPropType = 26;
  inline bool has_addproptype() const;
  inline void clear_addproptype();
  static const int kAddPropTypeFieldNumber = 26;
  inline ::google::protobuf::int32 addproptype() const;
  inline void set_addproptype(::google::protobuf::int32 value);

  // optional int32 PropValue = 27;
  inline bool has_propvalue() const;
  inline void clear_propvalue();
  static const int kPropValueFieldNumber = 27;
  inline ::google::protobuf::int32 propvalue() const;
  inline void set_propvalue(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dbc.SkillValue)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_trigtype();
  inline void clear_has_trigtype();
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_cd();
  inline void clear_has_cd();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_upgradegold();
  inline void clear_has_upgradegold();
  inline void set_has_upgrademat();
  inline void clear_has_upgrademat();
  inline void set_has_matnum();
  inline void clear_has_matnum();
  inline void set_has_targettype();
  inline void clear_has_targettype();
  inline void set_has_targetcnt();
  inline void clear_has_targetcnt();
  inline void set_has_hurttype();
  inline void clear_has_hurttype();
  inline void set_has_damfactor();
  inline void clear_has_damfactor();
  inline void set_has_damaddtion();
  inline void clear_has_damaddtion();
  inline void set_has_bufftrigrate();
  inline void clear_has_bufftrigrate();
  inline void set_has_buffid();
  inline void clear_has_buffid();
  inline void set_has_enmityaddtion();
  inline void clear_has_enmityaddtion();
  inline void set_has_souladdtion();
  inline void clear_has_souladdtion();
  inline void set_has_isbrk();
  inline void clear_has_isbrk();
  inline void set_has_isfirectrl();
  inline void clear_has_isfirectrl();
  inline void set_has_flashrange();
  inline void clear_has_flashrange();
  inline void set_has_isverify();
  inline void clear_has_isverify();
  inline void set_has_addproptype();
  inline void clear_has_addproptype();
  inline void set_has_propvalue();
  inline void clear_has_propvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* desc_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::std::string* icon_;
  ::google::protobuf::int32 trigtype_;
  ::google::protobuf::int32 slot_;
  float cd_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 upgradegold_;
  ::google::protobuf::int32 upgrademat_;
  ::google::protobuf::int32 matnum_;
  ::google::protobuf::int32 targettype_;
  ::google::protobuf::int32 targetcnt_;
  ::google::protobuf::int32 hurttype_;
  float damfactor_;
  float damaddtion_;
  float bufftrigrate_;
  ::google::protobuf::int32 buffid_;
  float enmityaddtion_;
  float souladdtion_;
  bool isbrk_;
  bool isfirectrl_;
  bool isverify_;
  float flashrange_;
  ::google::protobuf::int32 addproptype_;
  ::google::protobuf::int32 propvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  friend void  protobuf_AddDesc_SkillValue_2eproto();
  friend void protobuf_AssignDesc_SkillValue_2eproto();
  friend void protobuf_ShutdownFile_SkillValue_2eproto();

  void InitAsDefaultInstance();
  static SkillValue* default_instance_;
};
// ===================================================================


// ===================================================================

// SkillValueTable

// optional string tname = 1;
inline bool SkillValueTable::has_tname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillValueTable::set_has_tname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillValueTable::clear_has_tname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillValueTable::clear_tname() {
  if (tname_ != &::google::protobuf::internal::kEmptyString) {
    tname_->clear();
  }
  clear_has_tname();
}
inline const ::std::string& SkillValueTable::tname() const {
  return *tname_;
}
inline void SkillValueTable::set_tname(const ::std::string& value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
}
inline void SkillValueTable::set_tname(const char* value) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  tname_->assign(value);
}
inline void SkillValueTable::set_tname(const char* value, size_t size) {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  tname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillValueTable::mutable_tname() {
  set_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    tname_ = new ::std::string;
  }
  return tname_;
}
inline ::std::string* SkillValueTable::release_tname() {
  clear_has_tname();
  if (tname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tname_;
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillValueTable::set_allocated_tname(::std::string* tname) {
  if (tname_ != &::google::protobuf::internal::kEmptyString) {
    delete tname_;
  }
  if (tname) {
    set_has_tname();
    tname_ = tname;
  } else {
    clear_has_tname();
    tname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .dbc.SkillValue tlist = 2;
inline int SkillValueTable::tlist_size() const {
  return tlist_.size();
}
inline void SkillValueTable::clear_tlist() {
  tlist_.Clear();
}
inline const ::dbc::SkillValue& SkillValueTable::tlist(int index) const {
  return tlist_.Get(index);
}
inline ::dbc::SkillValue* SkillValueTable::mutable_tlist(int index) {
  return tlist_.Mutable(index);
}
inline ::dbc::SkillValue* SkillValueTable::add_tlist() {
  return tlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dbc::SkillValue >&
SkillValueTable::tlist() const {
  return tlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::dbc::SkillValue >*
SkillValueTable::mutable_tlist() {
  return &tlist_;
}

// -------------------------------------------------------------------

// SkillValue

// optional int32 ID = 1;
inline bool SkillValue::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillValue::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillValue::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillValue::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SkillValue::id() const {
  return id_;
}
inline void SkillValue::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string Name = 2;
inline bool SkillValue::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillValue::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillValue::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SkillValue::name() const {
  return *name_;
}
inline void SkillValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SkillValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SkillValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SkillValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Desc = 3;
inline bool SkillValue::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillValue::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillValue::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillValue::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& SkillValue::desc() const {
  return *desc_;
}
inline void SkillValue::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void SkillValue::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void SkillValue::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillValue::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* SkillValue::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillValue::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Icon = 4;
inline bool SkillValue::has_icon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillValue::set_has_icon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillValue::clear_has_icon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillValue::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& SkillValue::icon() const {
  return *icon_;
}
inline void SkillValue::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void SkillValue::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void SkillValue::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillValue::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* SkillValue::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillValue::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Type = 5;
inline bool SkillValue::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkillValue::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkillValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkillValue::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SkillValue::type() const {
  return type_;
}
inline void SkillValue::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 TrigType = 6;
inline bool SkillValue::has_trigtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SkillValue::set_has_trigtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SkillValue::clear_has_trigtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SkillValue::clear_trigtype() {
  trigtype_ = 0;
  clear_has_trigtype();
}
inline ::google::protobuf::int32 SkillValue::trigtype() const {
  return trigtype_;
}
inline void SkillValue::set_trigtype(::google::protobuf::int32 value) {
  set_has_trigtype();
  trigtype_ = value;
}

// optional int32 Slot = 7;
inline bool SkillValue::has_slot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SkillValue::set_has_slot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SkillValue::clear_has_slot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SkillValue::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 SkillValue::slot() const {
  return slot_;
}
inline void SkillValue::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// optional float CD = 8;
inline bool SkillValue::has_cd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SkillValue::set_has_cd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SkillValue::clear_has_cd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SkillValue::clear_cd() {
  cd_ = 0;
  clear_has_cd();
}
inline float SkillValue::cd() const {
  return cd_;
}
inline void SkillValue::set_cd(float value) {
  set_has_cd();
  cd_ = value;
}

// optional int32 Level = 9;
inline bool SkillValue::has_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SkillValue::set_has_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SkillValue::clear_has_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SkillValue::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SkillValue::level() const {
  return level_;
}
inline void SkillValue::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 UpgradeGold = 10;
inline bool SkillValue::has_upgradegold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SkillValue::set_has_upgradegold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SkillValue::clear_has_upgradegold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SkillValue::clear_upgradegold() {
  upgradegold_ = 0;
  clear_has_upgradegold();
}
inline ::google::protobuf::int32 SkillValue::upgradegold() const {
  return upgradegold_;
}
inline void SkillValue::set_upgradegold(::google::protobuf::int32 value) {
  set_has_upgradegold();
  upgradegold_ = value;
}

// optional int32 UpgradeMat = 11;
inline bool SkillValue::has_upgrademat() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SkillValue::set_has_upgrademat() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SkillValue::clear_has_upgrademat() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SkillValue::clear_upgrademat() {
  upgrademat_ = 0;
  clear_has_upgrademat();
}
inline ::google::protobuf::int32 SkillValue::upgrademat() const {
  return upgrademat_;
}
inline void SkillValue::set_upgrademat(::google::protobuf::int32 value) {
  set_has_upgrademat();
  upgrademat_ = value;
}

// optional int32 MatNum = 12;
inline bool SkillValue::has_matnum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SkillValue::set_has_matnum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SkillValue::clear_has_matnum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SkillValue::clear_matnum() {
  matnum_ = 0;
  clear_has_matnum();
}
inline ::google::protobuf::int32 SkillValue::matnum() const {
  return matnum_;
}
inline void SkillValue::set_matnum(::google::protobuf::int32 value) {
  set_has_matnum();
  matnum_ = value;
}

// optional int32 TargetType = 13;
inline bool SkillValue::has_targettype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SkillValue::set_has_targettype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SkillValue::clear_has_targettype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SkillValue::clear_targettype() {
  targettype_ = 0;
  clear_has_targettype();
}
inline ::google::protobuf::int32 SkillValue::targettype() const {
  return targettype_;
}
inline void SkillValue::set_targettype(::google::protobuf::int32 value) {
  set_has_targettype();
  targettype_ = value;
}

// optional int32 TargetCnt = 14;
inline bool SkillValue::has_targetcnt() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SkillValue::set_has_targetcnt() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SkillValue::clear_has_targetcnt() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SkillValue::clear_targetcnt() {
  targetcnt_ = 0;
  clear_has_targetcnt();
}
inline ::google::protobuf::int32 SkillValue::targetcnt() const {
  return targetcnt_;
}
inline void SkillValue::set_targetcnt(::google::protobuf::int32 value) {
  set_has_targetcnt();
  targetcnt_ = value;
}

// optional int32 HurtType = 15;
inline bool SkillValue::has_hurttype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SkillValue::set_has_hurttype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SkillValue::clear_has_hurttype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SkillValue::clear_hurttype() {
  hurttype_ = 0;
  clear_has_hurttype();
}
inline ::google::protobuf::int32 SkillValue::hurttype() const {
  return hurttype_;
}
inline void SkillValue::set_hurttype(::google::protobuf::int32 value) {
  set_has_hurttype();
  hurttype_ = value;
}

// optional float DamFactor = 16;
inline bool SkillValue::has_damfactor() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SkillValue::set_has_damfactor() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SkillValue::clear_has_damfactor() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SkillValue::clear_damfactor() {
  damfactor_ = 0;
  clear_has_damfactor();
}
inline float SkillValue::damfactor() const {
  return damfactor_;
}
inline void SkillValue::set_damfactor(float value) {
  set_has_damfactor();
  damfactor_ = value;
}

// optional float DamAddtion = 17;
inline bool SkillValue::has_damaddtion() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SkillValue::set_has_damaddtion() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SkillValue::clear_has_damaddtion() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SkillValue::clear_damaddtion() {
  damaddtion_ = 0;
  clear_has_damaddtion();
}
inline float SkillValue::damaddtion() const {
  return damaddtion_;
}
inline void SkillValue::set_damaddtion(float value) {
  set_has_damaddtion();
  damaddtion_ = value;
}

// optional float BuffTrigRate = 18;
inline bool SkillValue::has_bufftrigrate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SkillValue::set_has_bufftrigrate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SkillValue::clear_has_bufftrigrate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SkillValue::clear_bufftrigrate() {
  bufftrigrate_ = 0;
  clear_has_bufftrigrate();
}
inline float SkillValue::bufftrigrate() const {
  return bufftrigrate_;
}
inline void SkillValue::set_bufftrigrate(float value) {
  set_has_bufftrigrate();
  bufftrigrate_ = value;
}

// optional int32 BuffID = 19;
inline bool SkillValue::has_buffid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SkillValue::set_has_buffid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SkillValue::clear_has_buffid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SkillValue::clear_buffid() {
  buffid_ = 0;
  clear_has_buffid();
}
inline ::google::protobuf::int32 SkillValue::buffid() const {
  return buffid_;
}
inline void SkillValue::set_buffid(::google::protobuf::int32 value) {
  set_has_buffid();
  buffid_ = value;
}

// optional float EnmityAddtion = 20;
inline bool SkillValue::has_enmityaddtion() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SkillValue::set_has_enmityaddtion() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SkillValue::clear_has_enmityaddtion() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SkillValue::clear_enmityaddtion() {
  enmityaddtion_ = 0;
  clear_has_enmityaddtion();
}
inline float SkillValue::enmityaddtion() const {
  return enmityaddtion_;
}
inline void SkillValue::set_enmityaddtion(float value) {
  set_has_enmityaddtion();
  enmityaddtion_ = value;
}

// optional float SoulAddtion = 21;
inline bool SkillValue::has_souladdtion() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SkillValue::set_has_souladdtion() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SkillValue::clear_has_souladdtion() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SkillValue::clear_souladdtion() {
  souladdtion_ = 0;
  clear_has_souladdtion();
}
inline float SkillValue::souladdtion() const {
  return souladdtion_;
}
inline void SkillValue::set_souladdtion(float value) {
  set_has_souladdtion();
  souladdtion_ = value;
}

// optional bool IsBrk = 22;
inline bool SkillValue::has_isbrk() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SkillValue::set_has_isbrk() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SkillValue::clear_has_isbrk() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SkillValue::clear_isbrk() {
  isbrk_ = false;
  clear_has_isbrk();
}
inline bool SkillValue::isbrk() const {
  return isbrk_;
}
inline void SkillValue::set_isbrk(bool value) {
  set_has_isbrk();
  isbrk_ = value;
}

// optional bool IsFireCtrl = 23;
inline bool SkillValue::has_isfirectrl() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SkillValue::set_has_isfirectrl() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SkillValue::clear_has_isfirectrl() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SkillValue::clear_isfirectrl() {
  isfirectrl_ = false;
  clear_has_isfirectrl();
}
inline bool SkillValue::isfirectrl() const {
  return isfirectrl_;
}
inline void SkillValue::set_isfirectrl(bool value) {
  set_has_isfirectrl();
  isfirectrl_ = value;
}

// optional float FlashRange = 24;
inline bool SkillValue::has_flashrange() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SkillValue::set_has_flashrange() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SkillValue::clear_has_flashrange() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SkillValue::clear_flashrange() {
  flashrange_ = 0;
  clear_has_flashrange();
}
inline float SkillValue::flashrange() const {
  return flashrange_;
}
inline void SkillValue::set_flashrange(float value) {
  set_has_flashrange();
  flashrange_ = value;
}

// optional bool IsVerify = 25;
inline bool SkillValue::has_isverify() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SkillValue::set_has_isverify() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SkillValue::clear_has_isverify() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SkillValue::clear_isverify() {
  isverify_ = false;
  clear_has_isverify();
}
inline bool SkillValue::isverify() const {
  return isverify_;
}
inline void SkillValue::set_isverify(bool value) {
  set_has_isverify();
  isverify_ = value;
}

// optional int32 AddPropType = 26;
inline bool SkillValue::has_addproptype() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SkillValue::set_has_addproptype() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SkillValue::clear_has_addproptype() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SkillValue::clear_addproptype() {
  addproptype_ = 0;
  clear_has_addproptype();
}
inline ::google::protobuf::int32 SkillValue::addproptype() const {
  return addproptype_;
}
inline void SkillValue::set_addproptype(::google::protobuf::int32 value) {
  set_has_addproptype();
  addproptype_ = value;
}

// optional int32 PropValue = 27;
inline bool SkillValue::has_propvalue() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SkillValue::set_has_propvalue() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SkillValue::clear_has_propvalue() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SkillValue::clear_propvalue() {
  propvalue_ = 0;
  clear_has_propvalue();
}
inline ::google::protobuf::int32 SkillValue::propvalue() const {
  return propvalue_;
}
inline void SkillValue::set_propvalue(::google::protobuf::int32 value) {
  set_has_propvalue();
  propvalue_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dbc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SkillValue_2eproto__INCLUDED
